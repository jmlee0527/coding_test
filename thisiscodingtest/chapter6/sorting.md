# 정렬 (Sorting)

### 정렬 - 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

## 선택 정렬
가장 원시적인 방법으로 매번 가장 작은 데이터를 선택하는 정렬 방식이다.


즉, 먼저 가장 작은 데이터를 선택해 맨 앞의 데이터와 바꾸고 그다음 작은 데이터를 선택해 두번째 데이터와 바꾸는 과정을 반복하는 것이다.
이 과정을 반복하면 전체 데이터 정렬이 이루어진다.


"현재 정렬되지 않은 데이터 중 가장 작은 데이터", "이미 정렬된 데이터" 두가지를 확인하여 선택정렬 알고리즘을 사용할 수 있다.

#### <선택 정렬 소스코드>

    array = []

    for i in range(len(array)):
        min_index = i
        for j in range(i+1,len(array)):
            if array[min_index]>array[j]:
                min_index = j
        array[i], array[min_index] = array[min_index],array[i]

#### 시간복잡도
n-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보낸다. 또한 매번 최소값을 찾기 위한 비교 연산을 수행한다.


이때 비교 연산 횟수는 n + (n-1) + ... +2 이므로 n*(n_1)//2 만큼의 연산을 수행한다.


-> O(N^2)

## 삽입 정렬
삽입 정렬은 데이터를 하나씩 확인하며 해당 데이터를 적절한 위치에 삽입하도록 한다.


삽입 정렬은 필요시에만 위치를 수정하므로 데이터가 전체적으로 정렬되어있을 때 유리하게 사용될 수 있다.


삽입 정렬은 특정 데이터 이전의 데이터는 정렬되어있다는 가정하고 특정 데이터를 적절한 위치에 삽입한다.

#### <삽입 정렬 소스코드>

    array =[]
    for i in range(1,len(array)):
        for j in range(i,0,-1):
            if array[j] < array[j-1]
                array[j], array[j-1] = array[j-1],array[j]
            else:
                break

#### 시간복잡도
반복문이 2번 중첩되어 사용되었고 시간복잡도는 O(N^2)이다.


거의 정렬이 되어있는 경우에는 퀵 정렬보다 삽입 정렬을 사용하는 것이 효율적일 수 있으며 최적의 경우 O(N)의 시간복잡도를 갖는다.

## 퀵 정렬
가장 빠르게 동작하고 많이 사용되는 정렬 알고리즘이다.


기준이 되는 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터를 바꾸는 방식을 반복한다.


리스트를 반으로 나누어 위와 같은 방식을 반복하는 분할 방식을 사용한다.


피벗(pivot)은 큰 숫자와 작은 숫자를 교환하기 위한 기준이 되는 값이다.

#### <퀵 정렬 소스코드>

    array = []

    def quick_sort(array):
        if len(array) <= 1:
            return array

        pivot = array[0]
        tail = array[1:]            #피벗을 제외한 나머지 리스트

        left_side = [x for x in tail if x<= pivot]
        right_side = [x for x in tail if x> pivot]

        return quick_sort(left_side) + [pivot] + quick_sort(right_side)
    
#### 시간복잡도
퀵 정렬의 경우 평균 시간 복잡도는 O(NlogN)이다. 하지만 최악의 경우 O(N^2)의 시간복잡도를 갖는다.(이미 정렬되어 있는 경우 매우 느리게 동작한다.)


이전의 두가지 정렬 방식에 비해 매우 빠른 편이다.


데이터의 개수가 많을 수록 시간 복잡도의 차이가 크다는 것을 확인할 수 있다.

## 계수 정렬
매우 빠른 정렬 알고리즘이지만 특정한 조건이 부합할 때만 사용할 수 있다.


계수 정렬은 데이터의 크기 범위가 제한 되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.


일반적으로 가장 큰 데이터와 가장 작은 데이터 차이가 1,000,000을 넘지 않을 때 효과적인 사용이 가능하다.


기존의 3가지 정렬 알고리즘처럼 직접 데이터 값을 비교한 뒤에 위치를 변경하는 방식이 아니다.


데이터의 최대값과 최소값에 해당하는 크기의 리스트를 선언하고 데이터 값과 동일한 인덱스의 데이터를 1씩 증가시키면서 계수 정렬을 한다.


정렬된 리스트의 인덱스 값에 해당하는 개수 만큼 인덱스 값을 출력하면 정렬된 출력값을 구할 수 있는 것이다.

#### <계수 정렬 소스코드>

    array =[7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
    count = [0]* (max(array)+1)

    for i in range(len(array)):
        count[array[i]] += 1

    for i in range(len(count)):
        for j in range(count[i]):
            print(i,end = ' ')

#### 공간 복잡도
계수 정렬은 비효율적인 경우도 발생하게 된다. 예를 들어 0,999999 두개의 데이터가 있는 경우에도 리스트의 크기가 100만개가 되도록 선언이 필요하기 때문이다.

즉, 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장하는 경우 적절하게 사용될 수 있다.

계수 정렬의 공간 복잡도는 O(N+K)이다.